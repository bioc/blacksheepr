---
title: "Outlier Analysis using blackSheepR - Phosphoprotein"
author: "MacIntosh Cornwell"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
package: blackSheepR
output: 
    BiocStyle::html_document:
        toc: true
abstract: >
    BlackSheep is used to perform extreme value analysis in the context of 
    differential comparison between two populations. The basic mechanism is to 
    test the proportions of outliers between the two populations, and assess for
    statistical difference between the proportions of outliers.
vignette: >
    %\VignetteIndexEntry{Outlier Analysis using blackSheepR - Phosphoprotein}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Outlier analysis is a well established method for exploring extreme values in
the context of the rest of the population. In biological contexts, exploring the
shift in proportion of these outliers can elucidate differences between 
subpopulations, suggesting potential differential characteristics that can be 
further explored.
BlackSheep is a project that was developed in an effort to refine this analysis 
to a functional tool for outlier analysis in the context of biological data. 
This data can take many forms: protein, phosphoprotein, RNA, CNA, etc. The input
for Blacksheep is count data of some form, and annotation data indicative of the
populations for comparison.
This vignette will run through a few standard use-cases, illustrating the 
functionality of BlackSheep and hopefully answering questions and showing its 
usefulness in biological exploration.

## Installation:
Installation is similar to all Bioconductor packages. Start R and run the 
following lines to install:
```{r install package, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("blackSheepR")
```
Loading the library is done by using the `library` call
```{r library call}
library(blackSheepR)
```

## Input Data
##### 1 - Count data
Count data should be a table of counts with samples along the x-axis, and 
features along the y-axis, with the labels being rownames and colnames.

```{r countdata example}
library(blackSheepR)
data("sample_values")
sample_values[1:5,1:5]
```

##### 2 - Annotation data
The Annotation data should be a table with the same samples included in your 
count data, listed along the y-axis. Each column will then be a comparison to 
perform, with the values of the column being some form of binary system 
indicating the samples belonging to each sub group.
NOTE - that these should be strings. It's more informative if your columns 
actually contain useful information such as "high"/"low", "mutant"/"WT", etc.
```{r annotation example}
data("sample_annotations")
sample_annotations[1:5,1:5]
```


# Example Workflow - Phosphoprotein
In the following section - we will go through an example of using outlier 
analysis using Phosphoprotein data. The inputted data is being supplied from 
[Github](https://github.com/ruggleslab/blacksheep_supp/tree/master) and is from 
breast cancer data from TCGA and CPTAC.
NOTE - that this analysis is more complicated then RNA due to the additional 
functionality of aggregating together multiple phospho sites per protein. More 
on this later.

### Read in Annotation
Read in the Annotation table. We will also define a variable
`outfilepath` which is used in a number of functions as a location to save data 
out to. This will currently be set to the working directory - but the user can 
set this to their desired location.
```{r read in data - phospho, echo = TRUE}
library(curl)
annotationtable = read.table(curl(paste0("https://raw.githubusercontent.com/",
                    "ruggleslab/blacksheep_supp/dev/vignettes/brca/",
                    "annotations_common_samples.csv")), header = TRUE,
                    row.names = 1, na.strings = c("", " ", "NA"), sep = ",",
                    check.names = FALSE, stringsAsFactors = FALSE)
colnames(annotationtable) = gsub(" ", "_", colnames(annotationtable))
compcols = annotationtable[,c("PAM50", "ER_Status", "PR_Status",
                        "GATA3_Mutation", "PIK3CA_Mutation", "TP53_Mutation")]

outfilepath = getwd()

compcols[1:5,1:5]
dim(compcols)

```

#### Formatting our annotation data
Before we continue, we are going to format our annotation data to be ready for
further analysis. The driving concept behind this work is to have a PAIRWISE 
analysis, so we are going to format our data into readable pairwise information.

First - we are going to manually make a few edits to change our columns into 
binary metrics - "mutant" and "none"

``` {r format annotation data1 - phospho, echo=FALSE} 
## FORMAT our annotation table
compcols[,"GATA3_Mutation"] = ifelse(is.na(compcols[,4]), "None", "Mutant")
compcols[,"PIK3CA_Mutation"] = ifelse(is.na(compcols[,5]), "None", "Mutant")
compcols[,"TP53_Mutation"] = ifelse(is.na(compcols[,6]), "None", "Mutant")
head(compcols)
```

#### Using the make_comparison_columns utility function
Then we are going to use a built in utility function `make_comparison_columns` 
to help turn a multifactor column into several binary columns

``` {r format annotation data2 - phospho}
## Use the make_comparison_columns function to create binary columns
expanded_compcols = make_comparison_columns(compcols[,1,drop=FALSE])
## Append new columns to the comparison annotation table
comptable = cbind.data.frame(expanded_compcols, compcols[2:ncol(compcols)],
                             stringsAsFactors = FALSE)
head(comptable)
```

### Read in the phospho data
Next we need to have the actual count data that we are analyzing. Note that 
this data is made up of features - proteins - that then have a number of 
subfeatures - phosphorylation sites. This aspect of the data will directly 
relate to later analysis, as blacksheep will AGGREGATE on this data and 
collapse the data onto the primary feature. More on this later.
```{r}
phosphocountfile = paste0("/Users/tosh/Desktop/Ruggles_Lab/projects/",
                    "outlier-tool/data/brca/phospho_common_samples_data.csv")
phosphotable = read.table(phosphocountfile, header = TRUE, row.names = 1, 
                        sep = ",", quote = "", check.names = FALSE)

phosphotable[1:5,1:5]
dim(phosphotable)
```

### Creating a SummarizedExperiment from our data.
Blacksheep - as a part of the Bioconductor universe - starts from a single 
object that contains the assay of interest, and the underlying metadata. A 
`SummarizedExperiment` object is easy to create - and helps ensure that there 
is no misalignment between the data and the metadata associated with each 
sample.
NOTE - as demonstrated below that the count data must be formatted as a MATRIX 
and the annotation data must be formatted as a DATAFRAME.
```{r summarized experiment}
suppressPackageStartupMessages(library(SummarizedExperiment))

blacksheep_SE = SummarizedExperiment(
    assays=list(counts=as.matrix(phosphotable)), 
    colData=DataFrame(comptable))
blacksheep_SE
```

### Running BlackSheep
The blacksheep function has a number of steps to it that are individually 
described below. Note though that the individual steps only need to be used for 
specific query or alteration. In the general case, the `blacksheep` function on 
its own should be sufficient for the desired analysis.
```{r deva, fig.keep="none"}
blacksheep_out = deva(se = blacksheep_SE, 
    analyze_negative_outliers = FALSE, aggregate_features = TRUE, 
    feature_delineator = "-", fdrcutoffvalue = 0.1, write_out = FALSE)
```

The output from blacksheep are lists with the desired results. The number of 
lists depends on the parameters. Their is an `outlier_analysis` and a 
`significant_heatmaps` for the positive outliers (2 total) and for negative 
outliers (2 more) if the parameter is turned on. In this example, we only ran 
analysis for positive outliers. So the output will be 2 items long.

The `outlier_analysis` is a nested list of analyses - with one anaysis per 
comparison columns
```{r}
names(blacksheep_out$pos_outlier_analysis)
```

Each of these entries is a table of analysis - which can be accessed directly 
for further analysis, or writing out.
```{r}
head(blacksheep_out$pos_outlier_analysis$
    outlieranalysis_for_PAM50_Her2__Her2_vs_PAM50_Her2__not_Her2)
```

The heatmaps serve as a snapshot of the significant genes that met the 
parameterized fdr cutoff in the `blacksheep` function can. They can be accessed 
in a similar manner to the analysis tables. NOTE though that there will only be 
a heatmap if there were ANY significant genes. If there were no genes that met 
the fdr cut off - then there will be no heatmap generated
```{r}
names(blacksheep_out$significant_pos_heatmaps)
```

The heatmap objects themselves are `ComplexHeatmap` objects - and will be drawn 
when called - which will output in the default Rplot, in the plot window of 
Rstudio, or can be called in the context of a pdf file to output the plot

```{r}
blacksheep_out$significant_pos_heatmaps$
    print_outlieranalysis_for_PAM50_Basal__not_Basal_vs_PAM50_Basal__Basal

## NOT RUN
## To output separately to pdf
#pdf(outfile.pdf)
#blacksheep_out$significant_pos_heatmaps$
#    print_outlieranalysis_for_PAM50_Basal__not_Basal_vs_PAM50_Basal__Basal
#dev.off()
```




# Piecewise analysis - PHOSPHO
THIS SECTION ASSUMES THAT THE PREVIOUS STEPS FOR READING IN THE DATA AND 
ANNOTATIONS HAS BEEN COMPLETED.
The next section demonstrates the individual steps of blacksheep. NOTE that the 
user may never need to call the specific steps, but if specific tweaks are 
needed, or if an intermediate step needs to be extracted, then this workflow 
can be followed to see how the analysis is generated.

### Create groupings
Create the subgroups based on your metadata. Note that the 
`comparison_groupings` function creates groups by going through the comparison 
columns, and creating the first subgroup for all of the comparisons, and then 
creates the second subgroup for all of the comparisons. The order depends on 
the first subcategory encounted moving down the column. This order will matter
later on when you look at comparisons, but this information will be contained 
in the ouput table to avoid confusion, more on this later.
```{r groupings - phospho}
groupings = comparison_groupings(comptable)
## Print out the first 6 samples in each of our first 5 groupings
lapply(groupings, head)[1:5]
```

### Make Outlier table
The next function `make_outlier_table` will take in the countdata and output a 
table that has been converted to show outliers. A value of 0 means that it was 
not an outlier, 1 means it was an outlier in the positive direction, and if the 
parameter is set to analyze negative outliers, then -1 means an outlier in the 
negative direction.

```{r make outlier table - phospho}
## Perform the function
reftable_function_out = make_outlier_table(phosphotable)
## See the names of the outputted objects
names(reftable_function_out)
## Assign them to individual variables
outliertab = reftable_function_out$outliertab
upperboundtab = reftable_function_out$upperboundtab
sampmedtab = reftable_function_out$sampmedtab

## Note we will only use the outlier table - which looks like this now
outliertab[1:5,1:5]
```

### Tabulate Outliers
For each of our groups, run through the outlier table and count up the total 
number of outliers and nonoutliers. For phospho (And this example) we are going 
to use the AGGREGATION FUNCTION to aggregate our counts together on a per 
protein basis

The output from this function is a list of objects, that depends on the input 
and the specified parameters. For Phosphoprotein - you can have data that has 
several phospho sites per protein. As a part of this analysis, one option is to 
aggregate data on that protein - and collapse the outlier information into a 
single feature. Turning `aggregate_features = TRUE` will perform this function, 
and the `feature_delineator` is the character string to collapse on
ex) Feature1-1 and Feature1-2-1 with the delineator of "-" will collapse onto 
Feature 1

The output with `aggregate_features = TRUE` will contain two additional 
objects. It will output the normal outliertable, and boundary tables, and also 
the "aggoutlierstab" and "aggfractiontab"
The "aggoutlierstab" will be the collapsed table, summing up the number of 
outliers per feature
The "aggfractiontab" returns the % outliers per feature per sample, given 
available information - this will be IMPORTANT FOR FURTHER FILTERING later on.
ex) 1,0,0 >> 1/3
ex) 1,0,NA >> 1/2

```{r groupingtablist - phospho}
count_outliers_out = count_outliers(groupings, outliertab, 
                        aggregate_features = TRUE, feature_delineator = "-")
grouptablist = count_outliers_out$grouptablist
aggoutliertab = count_outliers_out$aggoutliertab
aggfractiontab = count_outliers_out$aggfractiontab

names(grouptablist)
```

Each tabulated table has the feature counts, and the stored infor the samples 
that went into the count
```{r}
names(grouptablist[[1]])
```
Example of what the feature counts look like:
```{r}
head(grouptablist[[1]][[1]])
```

Example of what the samples are that went into the analysis:
```{r}
grouptablist[[1]][[2]]
```

#### Run Outlier Analysis
With the tabulated tables, run the outlier analysis to look for enrichment of 
outliers between groups. NOTE that this function has a functionality built in 
to write out tables to the external file, we will not use this parameter now, 
but it can be set by turning the to parameter `write_out_tables = TRUE`

In this outlier analysis - we will have an additional filter included. The 
`aggfractiontab` outputted in the previous step has a metric that measure the 
number of samples in each group that have an outlier in them. In this next step 
we will use this information to filter for features that only have at least 
`0.3` (30%) of samples with an outlier. This filter is important because our 
aggregation step collapsed all of the sites down from each sample, and then we 
counted the total. If one sample had ALL of its sites as outliers - while 
interesting - this does not indicate the our entire ingroup has an 
overrepresentation - just that one sample. This filter enables a clearer 
analysis by only picking out features that have multiple samples with outliers.
NOTE that this can be omitted by just leaving the `fraction_table` parameter 
out or as a `NULL`
```{r outlier analysis - phospho}
outlier_analysis_out = outlier_analysis(grouptablist,
                                        fraction_table = aggfractiontab,
                                        fraction_samples_cutoff = 0.3)
names(outlier_analysis_out)
lapply(outlier_analysis_out, head)[1]
```

#### Plot Results using Heatmap Generating Function
After you have your results, its useful to have a snapshot of your results in a 
figure. blackSheepR includes a utility function to output a heatmap with custom 
annotations and data. Use the plotting function with the original annotation 
data, and populate the heatmap with whatever information you want to represent. 
In this case, we are going to populate the table with the fractions of outliers 
per feature. 
The outlier_analysis object is used to select the differential genes.
NOTE that you can write out the plot directly in the function using the given 
parameter `write_out_plot` or the saved object from the function is a heatmap, 
so you can open your own pdf and print out using the commented out code below.
```{r heatmap plotting - phospho, fig.keep="none"}
hm1 = outlier_heatmap(outlier_analysis_out = outlier_analysis_out, 
                counttab = aggfractiontab, metatable = comptable, 
                fdrcutoffvalue = 0.1)

## To output heatmap to pdf outside of the function
#pdf(paste0(outfilepath, "test_hm1.pdf"))
#hm1
#junk<-dev.off()
```

```{r heatmap plotting 1example - phospho}
hm1[[1]]
```











