---
title: "blackSheepR_Example"
author: "MacIntosh Cornwell"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
output: html_document
abstract: >
    BlackSheep is used to perform extreme value analysis in the context of 
    differential comparison between two populations. The basic mechanism is to 
    test the proportions of outliers between the two populations, and assess for
    statistical difference between the proportions of outliers.
vignette: >
    %\VignetteIndexEntry{Outlier Analysis using blackSheepR}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Outlier analysis is a well established method for exploring extreme values in
the context of the rest of the population. In biological contexts, exploring the
shift in proportion of these outliers can elucidate differences between 
subpopulations, suggesting potential differential characteristics that can be 
further explored.
BlackSheep is a project that was developed in an effort to refine this analysis 
to a functional tool for outlier analysis in the context of biological data. 
This data can take many forms: protein, phosphoprotein, RNA, CNA, etc. The input
for Blacksheep is count data of some form, and annotation data indicative of the
populations for comparison.
This vignette will run through a few standard use-cases, illustrating the 
functionality of BlackSheep and hopefully answering questions and showing its 
usefulness in biological exploration.

## Installation:
Installation is similar to all Bioconductor packages. Start R and run the 
following lines to install:
```{r install package, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("blackSheepR")
```
Loading the library is done by using the `library` call
```{r library call}
library(blackSheepR)
```

## Input Data
##### 1 - Count data
Count data should be a table of counts with samples along the x-axis, and 
features along the y-axis, with the labels being rownames and colnames.

```{r countdata example}
library(blackSheepR)
data("sample_values")
sample_values[1:5,1:5]
```

##### 2 - Annotation data
The Annotation data should be a table with the same samples included in your 
count data, listed along the y-axis. Each column will then be a comparison to 
perform, with the values of the column being some form of binary system 
indicating the samples belonging to each sub group.
NOTE - that these should be strings. It's more informative if your columns 
actually contain useful information such as "high"/"low", "mutant"/"WT", etc.
```{r annotation example}
data("sample_annotations")
sample_annotations[1:5,1:5]
```


# Example Workflow - RNA
In the following section - we will go through an example of using outlier 
analysis using RNA data. The inputted data is being supplied from 
[Github](https://github.com/ruggleslab/blacksheep_supp/tree/master) and is from 
breast cancer data from TCGA and CPTAC.  

### Read in Data
Read in the RNA and Annotation table. We will also define a variable
`outfilepath` which is used in a number of functions as a location to save data 
out to. Examples Below of the tables we will be using:
```{r read in data - rna, echo = FALSE}
annotationfile = paste0("/Users/tosh/Desktop/Ruggles_Lab/projects/",
                        "outlier-tool/data/brca/annotations_common_samples.csv")
annotationtable = read.table(annotationfile, header = TRUE, row.names = 1, 
                na.strings = c("", " ", "NA"), sep = ",", check.names = FALSE)
colnames(annotationtable) = gsub(" ", "_", colnames(annotationtable))
compcols = annotationtable[,c("PAM50", "ER_Status", "PR_Status",
                        "GATA3_Mutation", "PIK3CA_Mutation", "TP53_Mutation")]

rnacountfile = paste0("/Users/tosh/Desktop/Ruggles_Lab/projects/outlier-tool/",
                      "data/brca/rna_common_samples_data.csv")
rnatable = read.table(rnacountfile, header = TRUE, row.names = 1, sep = ",", 
                      quote = "", check.names = FALSE)

outfilepath = paste0("/Users/tosh/Desktop/Ruggles_Lab/projects/outlier-tool/",
                     "output_VIGNETTE/")
dir.create(outfilepath, recursive = TRUE, showWarnings = FALSE)

compcols[1:5,1:5]
dim(compcols)
rnatable[1:5,1:5]
dim(rnatable)
print("Testing for existance of outfilepath; <dir.exists(outfilepath)>")
dir.exists(outfilepath)

```

#### Formatting our annotation data
Before we continue, we are going to format our annotation data to be ready for
further analysis. The driving concept behind this work is to have a PAIRWISE 
analysis, so we are going to format our data into readable pairwise information.

First - we are going to manually make a few edits to change our columns into 
binary metrics - "mutant" and "none"

``` {r format annotation data1 - rna} 
## FORMAT our annotation table
compcols[,4] = ifelse(is.na(compcols[,4]), "None", "Mutant")
compcols[,5] = ifelse(is.na(compcols[,5]), "None", "Mutant")
compcols[,6] = ifelse(is.na(compcols[,6]), "None", "Mutant")
head(compcols)
```

Then we are going to use a built in utility function `make_comparison_columns` 
to help turn a multifactor column into several binary columns

``` {r format annotation data2 - rna}
## Use the make_comparison_columns function to create binary columns
expanded_compcols = make_comparison_columns(compcols[,1,drop=FALSE])
## Append new columns to the comparison annotation table
comptable = cbind(expanded_compcols, compcols[2:ncol(compcols)])
head(comptable)
```


### Create groupings
Create the subgroups based on your metadata. Note that the 
`comparison_groupings` function creates groups by going through the comparison 
columns, and creating the first subgroup for all of the comparisons, and then 
creates the second subgroup for all of the comparisons. The order depends on 
the first subcategory encounted moving down the column. This order will matter
later on when you look at comparisons, but this information will be contained 
in the ouput table to avoid confusion, more on this later.
```{r groupings - rna}
groupings = comparison_groupings(comptable)
## Print out the first 6 samples in each of our first 5 groupings
lapply(groupings, head)[1:5]

```

### Make Outlier table
The next function `make_outlier_table` will take in the countdata and output a 
table that has been converted to show outliers. A value of 0 means that it was 
not an outlier, 1 means it was an outlier in the positive direction, and if the 
parameter is set to analyze negative outliers, then -1 means an outlier in the 
negative direction.

The output from this function is a list of objects, that depends on the input 
and the specified parameters. Namely - it will output a $lowerboundtab only
if the parameter to analyze negative outliers is turned ON

```{r make outlier table - rna}
## Perform the function
reftable_function_out = make_outlier_table(rnatable)
## See the names of the outputted objects
names(reftable_function_out)
## Assign them to individual variables
outliertab = reftable_function_out$outliertab
upperboundtab = reftable_function_out$upperboundtab
sampmedtab = reftable_function_out$sampmedtab

## Note we will only use the outlier table - which looks like this now
outliertab[1:5,1:5]

```

### Tabulate Outliers
For each of our groups, run through the outlier table and count up the total 
number of outliers and nonoutliers. Note that this will output a list of length
1 - just with the name "grouptablist". In later iterations, parameters will 
enable different output. For now though - we are just going to use this single
embedded list
```{r groupingtablist - rna}
count_outliers_out = count_outliers(groupings, outliertab)
grouptablist = count_outliers_out$grouptablist

names(grouptablist)
```

Each tabulated table has the feature counts, and the stored infor the samples 
that went into the count
```{r}
names(grouptablist[[1]])
```
Example of what the feature counts look like:
```{r}
head(grouptablist[[1]][[1]])
```
Example of what the samples are that went into the analysis:
```{r}
grouptablist[[1]][[2]]
```


### Run Outlier Analysis
With the tabulated tables, run the outlier analysis to look for enrichment of 
outliers between groups. NOTE that this function has a functionality built in 
to write out tables to the external file, we will not use this parameter now, 
but it can be set by turning the to parameter `write_out_tables = TRUE`
```{r outlier analysis - rna}
## Run the outlier analysis function
outlier_analysis_out = outlier_analysis(grouptablist)
names(outlier_analysis_out)
lapply(outlier_analysis_out, head)[1]
```

### Plot Results using Heatmap Generating Function
After you have your results, its useful to have a snapshot of your results in a 
figure. blackSheepR includes a utility function to output a heatmap with custom 
annotations and data. Use the plotting function with the original annotation 
data, and populate the heatmap with whatever information you want to represent. 
The outlier_analysis object is used to select the differential genes.
NOTE that you can write out the plot directly in the function using the given 
parameter `write_out_plot` or the saved object from the function is a heatmap, 
so you can open your own pdf and print out using the commented out code below.
```{r heatmap plotting - rna, fig.keep="none"}
hm1 = outlier_heatmap(outlier_analysis_out = outlier_analysis_out, 
                      counttab = rnatable, metatable = comptable, 
                      fdrcutoffvalue = 0.1)

## To output heatmap to pdf outside of the function
#pdf(paste0(outfilepath, "test_hm1.pdf"))
#hm1
#junk<-dev.off()
```
```{r heatmap plotting 1example - rna}
hm1[[1]]
```






# Example Workflow - Phosphoprotein
In the following section - we will go through an example of using outlier 
analysis using Phosphoprotein data. The inputted data is being supplied from 
[Github](https://github.com/ruggleslab/blacksheep_supp/tree/master) and is from 
breast cancer data from TCGA and CPTAC.
NOTE - that this analysis is more complicated then RNA due to the additional 
functionality of aggregating together multiple phospho sites per protein.

### Read in Data
Read in the Phospho and Annotation table, selecting the last 5 columns of the 
annotation data to be used as comparison columns. We will also define a variable
`outfilepath` which is used in a number of functions as a location to save data 
out to
```{r read in data - phospho, echo = FALSE}
annotationfile = paste0("/Users/tosh/Desktop/Ruggles_Lab/projects/",
                        "outlier-tool/data/brca/annotations_common_samples.csv")
annotationtable = read.table(annotationfile, header = TRUE, row.names = 1, 
                na.strings = c("", " ", "NA"), sep = ",", check.names = FALSE)
colnames(annotationtable) = gsub(" ", "_", colnames(annotationtable))
compcols = annotationtable[,c("PAM50", "ER_Status", "PR_Status",
                        "GATA3_Mutation", "PIK3CA_Mutation", "TP53_Mutation")]

phosphocountfile = paste0("/Users/tosh/Desktop/Ruggles_Lab/projects/",
                    "outlier-tool/data/brca/phospho_common_samples_data.csv")
phosphotable = read.table(phosphocountfile, header = TRUE, row.names = 1, 
                        sep = ",", quote = "", check.names = FALSE)

outfilepath = paste0("/Users/tosh/Desktop/Ruggles_Lab/projects/outlier-tool/",
                     "output_VIGNETTE/")
dir.create(outfilepath, recursive = TRUE, showWarnings = FALSE)

compcols[1:5,1:5]
dim(compcols)
rnatable[1:5,1:5]
dim(rnatable)
print("Testing for existance of outfilepath; <dir.exists(outfilepath)>")
dir.exists(outfilepath)

```

### Formatting our annotation data
Before we continue, we are going to format our annotation data to be ready for
further analysis. The driving concept behind this work is to have a PAIRWISE 
analysis, so we are going to format our data into readable pairwise information.

First - we are going to manually make a few edits to change our columns into 
binary metrics - "mutant" and "none"

``` {r format annotation data1 - phospho} 
## FORMAT our annotation table
compcols[,4] = ifelse(is.na(compcols[,4]), "None", "Mutant")
compcols[,5] = ifelse(is.na(compcols[,5]), "None", "Mutant")
compcols[,6] = ifelse(is.na(compcols[,6]), "None", "Mutant")
head(compcols)
```
Then we are going to use a built in utility function `make_comparison_columns` 
to help turn a multifactor column into several binary columns

``` {r format annotation data2 - phospho}
## Use the make_comparison_columns function to create binary columns
expanded_compcols = make_comparison_columns(compcols[,1,drop=FALSE])
## Append new columns to the comparison annotation table
comptable = cbind(expanded_compcols, compcols[2:ncol(compcols)])
head(comptable)
```

### Create groupings
Create the subgroups based on your metadata. Note that the 
`comparison_groupings` function creates groups by going through the comparison 
columns, and creating the first subgroup for all of the comparisons, and then 
creates the second subgroup for all of the comparisons. The order depends on 
the first subcategory encounted moving down the column. This order will matter
later on when you look at comparisons, but this information will be contained 
in the ouput table to avoid confusion, more on this later.
```{r groupings - phospho}
groupings = comparison_groupings(comptable)
## Print out the first 6 samples in each of our first 5 groupings
lapply(groupings, head)[1:5]
```

### Make Outlier table
The next function `make_outlier_table` will take in the countdata and output a 
table that has been converted to show outliers. A value of 0 means that it was 
not an outlier, 1 means it was an outlier in the positive direction, and if the 
parameter is set to analyze negative outliers, then -1 means an outlier in the 
negative direction.

```{r make outlier table - phospho}
## Perform the function
reftable_function_out = make_outlier_table(phosphotable)
## See the names of the outputted objects
names(reftable_function_out)
## Assign them to individual variables
outliertab = reftable_function_out$outliertab
upperboundtab = reftable_function_out$upperboundtab
sampmedtab = reftable_function_out$sampmedtab

## Note we will only use the outlier table - which looks like this now
outliertab[1:5,1:5]
```

### Tabulate Outliers
For each of our groups, run through the outlier table and count up the total 
number of outliers and nonoutliers. For phospho (And this example) we are going 
to use the AGGREGATION FUNCTION to aggregate our counts together on a per 
protein basis

The output from this function is a list of objects, that depends on the input 
and the specified parameters. For Phosphoprotein - you can have data that has 
several phospho sites per protein. As a part of this analysis, one option is to 
aggregate data on that protein - and collapse the outlier information into a 
single feature. Turning `aggregate_features = TRUE` will perform this function, 
and the `feature_delineator` is the character string to collapse on
ex) Feature1-1 and Feature1-2-1 with the delineator of "-" will collapse onto 
Feature 1

The output with `aggregate_features = TRUE` will contain two additional 
objects. It will output the normal outliertable, and boundary tables, and also 
the "aggoutlierstab" and "aggfractiontab"
The "aggoutlierstab" will be the collapsed table, summing up the number of 
outliers per feature
The "aggfractiontab" returns the % outliers per feature per sample, given 
available information - this will be IMPORTANT FOR FURTHER FILTERING later on.
ex) 1,0,0 >> 1/3
ex) 1,0,NA >> 1/2

```{r groupingtablist - phospho}
count_outliers_out = count_outliers(groupings, outliertab, 
                        aggregate_features = TRUE, feature_delineator = "-")
grouptablist = count_outliers_out$grouptablist
aggoutliertab = count_outliers_out$aggoutliertab
aggfractiontab = count_outliers_out$aggfractiontab

names(grouptablist)
```

Each tabulated table has the feature counts, and the stored infor the samples 
that went into the count
```{r}
names(grouptablist[[1]])
```
Example of what the feature counts look like:
```{r}
head(grouptablist[[1]][[1]])
```

Example of what the samples are that went into the analysis:
```{r}
grouptablist[[1]][[2]]
```

#### Run Outlier Analysis
With the tabulated tables, run the outlier analysis to look for enrichment of 
outliers between groups. NOTE that this function has a functionality built in 
to write out tables to the external file, we will not use this parameter now, 
but it can be set by turning the to parameter `write_out_tables = TRUE`

In this outlier analysis - we will have an additional filter included. The 
`aggfractiontab` outputted in the previous step has a metric that measure the 
number of samples in each group that have an outlier in them. In this next step 
we will use this information to filter for features that only have at least 
`0.3` (30%) of samples with an outlier. This filter is important because our 
aggregation step collapsed all of the sites down from each sample, and then we 
counted the total. If one sample had ALL of its sites as outliers - while 
interesting - this does not indicate the our entire ingroup has an 
overrepresentation - just that one sample. This filter enables a clearer 
analysis by only picking out features that have multiple samples with outliers.
NOTE that this can be omitted by just leaving the `fraction_table` parameter 
out or as a `NULL`
```{r outlier analysis - phospho}
outlier_analysis_out = outlier_analysis(grouptablist,
                                        fraction_table = aggfractiontab,
                                        fraction_samples_cutoff = 0.3)
names(outlier_analysis_out)
lapply(outlier_analysis_out, head)[1]
```

#### Plot Results using Heatmap Generating Function
After you have your results, its useful to have a snapshot of your results in a 
figure. blackSheepR includes a utility function to output a heatmap with custom 
annotations and data. Use the plotting function with the original annotation 
data, and populate the heatmap with whatever information you want to represent. 
In this case, we are going to populate the table with the fractions of outliers 
per feature. 
The outlier_analysis object is used to select the differential genes.
NOTE that you can write out the plot directly in the function using the given 
parameter `write_out_plot` or the saved object from the function is a heatmap, 
so you can open your own pdf and print out using the commented out code below.
```{r heatmap plotting - phospho, fig.keep="none"}
hm1 = outlier_heatmap(outlier_analysis_out = outlier_analysis_out, 
                counttab = aggfractiontab, metatable = comptable, 
                fdrcutoffvalue = 0.1)

## To output heatmap to pdf outside of the function
#pdf(paste0(outfilepath, "test_hm1.pdf"))
#hm1
#junk<-dev.off()
```

```{r heatmap plotting 1example - phospho}
hm1[[1]]
```





